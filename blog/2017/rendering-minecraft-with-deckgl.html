<!DOCTYPE html>
<html>







<head>
	<!-- Meta -->
	<meta charset="UTF-8"/>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
	<meta name="generator" content="Jekyll">

	<title>Rendering A Minecraft World With deck.gl | Deck.gl Blog</title>

	<!-- CSS & fonts -->
  <link rel="stylesheet" id="font-link" href="https://d1a3f4spazzrp4.cloudfront.net/uber-fonts/3.1.0/refresh.css">
	<link rel="stylesheet" href="../css/main.css">

  <!-- Favicon -->
  <link rel="icon" href="../img/favicon.ico" type="image/x-icon">
  <link rel="shortcut icon" href="../img/favicon.ico" type="image/x-icon">

	<!-- RSS -->
	<link href="../feed.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" />

  <!-— facebook open graph tags -->
  <meta property="og:url" content="http://uber.github.io/deck.gl/blog/2017/rendering-minecraft-with-deckgl" />
  <meta property="og:title" content="Rendering A Minecraft World With deck.gl | Deck.gl Blog" />
  <meta property="og:description" content="I built a Minecraft Chunk Viewer, featuring a custom deck.gl layer that renders Minecraft blocks. Here's an in-depth look at how it works!" />
  <meta property="og:site_name" content="deck.gl" />
  <meta property="og:image" content="http://uber.github.io/deck.gl/blog/img/minecraft0.jpg" />
  
  <!-— twitter card tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@uber">
  <meta name="twitter:creator" content="@uber">
  <meta name="twitter:title" content="Rendering A Minecraft World With deck.gl | Deck.gl Blog">
  <meta name="twitter:description" content="I built a Minecraft Chunk Viewer, featuring a custom deck.gl layer that renders Minecraft blocks. Here's an in-depth look at how it works!">
  <meta name="twitter:image" content="http://uber.github.io/deck.gl/blog/img/minecraft0.jpg" />

</head>


<body>

  <!-- Header -->
  
<header class="">
  <div class="bg"/>
  <div class="container">
    <a class="logo" href="http://uber.github.io/deck.gl">deck.gl</a>
    <div class="menu-toggle" >
      <i class="icon icon-menu" ></i>
    </div>
    <div class="links">
      <a href="http://uber.github.io/deck.gl/#/examples">Gallery</a>
      <a href="http://uber.github.io/deck.gl/#/documentation">Documentation</a>
      <a href="http://uber.github.io/deck.gl/blog/latest" class="active">Blog</a>
    </div>
  </div>
</header>


  <div class="scroll-area">
    <div class="flexbox">

      <div class="flexbox__item">

        <!-- Main content -->
        <div class="container">

        <!-- Navigation -->
        



<div class="nav">

  <div class="breadcrumb">
    <a href="../">All Posts</a>
    &gt;
    
    <span>Rendering A Minecraft World With deck.gl</span>
    
  </div>

</div>


      	<main>

      		




<article id="post">

	<h1>Rendering A Minecraft World With deck.gl</h1>

  <div>
    <span class="date"><b>12 Apr 2017</b></span>

    <span class="author">by 
      
        <a href="http://github.com/Pessimistress">
          <b>Xiaoji Chen</b>
        </a>
      
    </span>

    <div class="share">
      <!-- Social media scripts -->
      <script>window.twttr = (function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0],
    t = window.twttr || {};
  if (d.getElementById(id)) return t;
  js = d.createElement(s);
  js.id = id;
  js.src = "https://platform.twitter.com/widgets.js";
  fjs.parentNode.insertBefore(js, fjs);

  t._e = [];
  t.ready = function(f) {
    t._e.push(f);
  };

  return t;
}(document, "script", "twitter-wjs"));</script>

<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.8";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>
      <div class="fb-share-button" data-href="http://uber.github.io/deck.gl/blog/2017/rendering-minecraft-with-deckgl" data-layout="button_count" data-size="small" data-mobile-iframe="true">
        <a class="fb-xfbml-parse-ignore" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://uber.github.io/deck.gl/blog/2017/rendering-minecraft-with-deckgl&amp;src=sdkpreparse">Share</a>
      </div>
      <div>
        <a class="twitter-share-button"
          href="https://twitter.com/intent/tweet?text=http://uber.github.io/deck.gl/blog/2017/rendering-minecraft-with-deckgl">
        Tweet</a>
      </div>
    </div>
  </div>

	<div class="content">
		<p>While working on <a href="./introducing-deckgl-v4.html">deck.gl v4</a>, I decided to have some fun and built a <a href="http://pessimistress.github.io/minecraft/">Minecraft Chunk Viewer</a> in the browser. Drag in a region file from your own world and explore the world in depth! Totally not cheating.</p>

<ul>
  <li><a href="http://minecraft.gamepedia.com/Chunk_format">Region files</a> are in your Minecraft’s save folder with names like <strong>r.12.34.mca</strong>. Check <a href="http://minecraft.gamepedia.com/.minecraft">this page</a> to see where to find them.</li>
  <li>Drag to rotate; drag while holding <em>shift</em> to pan</li>
  <li>Use the slider to slice the world</li>
  <li>Hover over a block to see details</li>
  <li>Click on the minimap to select other chunks; click while holding <em>shift</em> to select multiple chunks</li>
</ul>

<p aligh="center">
  <img width="900" src="../img/minecraft1.gif" />
</p>

<p>For those who are interested, I’ll dive into how this was built.</p>

<h2 id="an-overview-of-the-app">An Overview of the App</h2>

<p>The chunk viewer itself is a pretty straight forward React one page app. Here are some of the critical components of the <a href="https://github.com/Pessimistress/minecraft-chunk-viewer/tree/master/src">source code</a>:</p>

<ul>
  <li><code class="highlighter-rouge">app.js</code> - Root. Lays out all the components and stores all the states.</li>
  <li><code class="highlighter-rouge">components/orbit-controller.js</code>
  <br />The component that handles user interaction with the 3D view. It maps pointer and wheel input to changes in the deck.gl viewport. It is rendered as the parent of the <code class="highlighter-rouge">DeckGL</code> canvas to capture all pointer events.</li>
  <li><code class="highlighter-rouge">minecraft-layer/</code>
  <br />A custom deck.gl layer that does the rendering magic.</li>
  <li><code class="highlighter-rouge">utils/mca-parser.js</code>
  <br />Util functions that parse a <strong>.mca</strong> file. Based on the work of <a href="https://github.com/maxogden/minecraft-region">minecraft-region</a>.</li>
  <li><code class="highlighter-rouge">utils/orbit-viewport.js</code>
  <br />An implementation of the deck.gl <a href="http://uber.github.io/deck.gl/#/documentation/api-reference/viewport">Viewport</a> class, used by the <code class="highlighter-rouge">OrbitController</code>.</li>
</ul>

<p>When the file is loaded and chunks are selected, the app calls <code class="highlighter-rouge">readChunks()</code> from the parser utils to update the data. The world is represented as an array of block objects, each containing information such as position (in-game <code class="highlighter-rouge">x</code> <code class="highlighter-rouge">y</code> <code class="highlighter-rouge">z</code> coordinates), block id (type of block), block data (block-specific metadata), biome and light level.</p>

<p>Because deck.gl does not do dynamic z-sorting (to prioritize performance), it’s important to draw the solid blocks before the transparent ones to avoid depth clipping.
Luckily, in this use case the interesting view angle is always from top down. When loading the blocks, they are sorted by <code class="highlighter-rouge">y</code> from bottom to top, so that the lower levels are rendered first.</p>

<p>The data is then passed in to create an instance of the <code class="highlighter-rouge">MinecraftLayer</code> - the custom layer that renders Minecraft blocks.</p>

<h2 id="the-minecraft-layer">The Minecraft Layer</h2>

<h3 id="the-minecraftlayer-class">The MinecraftLayer Class</h3>

<p><a href="https://github.com/Pessimistress/minecraft-chunk-viewer/tree/master/src/minecraft-layer/index.js">MinecraftLayer</a> extends deck.gl’s base <code class="highlighter-rouge">Layer</code> class. At initialization (<code class="highlighter-rouge">initializeState()</code>), it does the following:</p>

<ul>
  <li>Creates a single instanced model that defines what to render. An instanced model duplicates the same geometry (“instance”) many times with slight variations. Naturally in Minecraft, each instance is a cube.</li>
  <li>Adds attributes. The attributes are per instance and determines how each cube will look. Each attribute has an <code class="highlighter-rouge">update</code> function that will only be called once when <code class="highlighter-rouge">props.data</code> changes. The attributes carry the following information to the vertex shader:
    <ul>
      <li><code class="highlighter-rouge">position</code> - the <code class="highlighter-rouge">x</code> <code class="highlighter-rouge">y</code> <code class="highlighter-rouge">z</code> coordinates of the block</li>
      <li><code class="highlighter-rouge">blockId</code> and <code class="highlighter-rouge">blockData</code> - <a href="http://minecraft.gamepedia.com/Data_values">block data values</a></li>
      <li><code class="highlighter-rouge">temperature</code> and <code class="highlighter-rouge">humidity</code> - used to calculate biome shading</li>
      <li><code class="highlighter-rouge">lighting</code> - the light level of a block, either from sky light or self illumination</li>
    </ul>
  </li>
  <li>Loads textures. The layer loads three textures that are sent to the shaders as uniforms:
    <ul>
      <li><code class="highlighter-rouge">blocks.png</code> - this is the encoded block metadata, will discuss below.</li>
      <li><code class="highlighter-rouge">textures.png</code> - this is an all-up texture atlas of all Minecraft textures.</li>
      <li><code class="highlighter-rouge">foliage.png</code> - this is the definition of biome colors, as explained <a href="http://www.planetminecraft.com/blog/biomes-controlling-color/">here</a>.</li>
    </ul>
  </li>
</ul>

<p>At each rendering cycle, the method <code class="highlighter-rouge">draw()</code> is called to render the model to the WebGL context.</p>

<h3 id="passing-block-metadata-to-the-gpu">Passing Block Metadata to the GPU</h3>

<p>An unique challenge in this project is that there are many variables playing into the appearance of a block. Each face of the cube has its own texture and biome shading behavior. To make a single cube geometry work with as many block types as possible, I introduced “transforms” that can be applied to each the block: rotation (e.g. logs), size (e.g. half slabs), translation (e.g. ladders) and face offset (e.g. flowers).</p>

<p><img src="../img/minecraft2.png" alt="Block Definition Examples" /></p>

<p>All together the texture properties and block transforms add up to 20+ float attributes per instance. Sadly WebGL1 does not handle arrays easily. To avoid creating a long list of attributes, I opt to encode all the block definitions into one image texture. There is an 8-pixels slot assigned to each (<code class="highlighter-rouge">blockId</code>, <code class="highlighter-rouge">blockData</code>) combination, and each channel (<code class="highlighter-rouge">r</code> <code class="highlighter-rouge">g</code> <code class="highlighter-rouge">b</code> <code class="highlighter-rouge">a</code>) can be used to store one property. Now the vertex shader can look up block definitions on the fly:</p>

<p><img src="https://github.com/Pessimistress/minecraft-chunk-viewer/blob/master/static/data/blocks.png?raw=true" alt="Encoded Block Definition" /></p>

<h3 id="the-shaders">The Shaders</h3>

<p>At render time, the vertex shader looks up block definitions using id, data value and face index. The block-level transforms are applied to vertex positions and normals. Texture coordinates are passed to the fragment shader, where colors are touched up with biome shading, lighting, mouse hover highlight, etc.</p>

<p>The Y-slicer position is passed in as a uniform and essentially reduces the alpha of all blocks above the given level. It is an inexpensive operation but extremely useful when you need to peek into the belly of a chunk. I am quite pleased with how it works out.</p>

<p><a href="../img/minecraft3.png" title="This is a very dry diagram. Click with discretion" target="_blank"><img width="900" src="../img/minecraft3.png" /></a></p>

<p>Here’s a big gotcha regarding the block definition lookup. When I first implemented it, the rendering result was a mess: grass blocks were consistently rendered as wood planks, dirt as cobble stones, and block orientations were all weird. I double and then triple checked my asset generation script, but everything looked correct. It seemed that the vertex shader was just reading the wrong rgb values out of the texture.</p>

<p>Turns out that <em>the rgb precision is affected by the alpha channel</em>. When alpha is 255, the rgb values are read exactly as what I wrote into the image. As the alpha decreases, the rgb values start to show an increasing margin of error. It makes sense in image display because when opacity is very low, the single-digit difference is rounded away by blending; but this becomes a big problem when I use them to encode texture indices. This behavior is also apparently GPU-dependent, because the same image worked on my Macbook and did not on iOS. The advice is to avoid using the alpha channel if possible, or at least keep the number in the upper range.</p>

<h3 id="optimization">Optimization</h3>

<p>A typical chunk is over 20k blocks, that is 240k triangles to render. When multiple chunks are selected, it quickly becomes too much for the browser. A cheap improvement is to turn on face culling (<code class="highlighter-rouge">gl.enable(gl.CULL_FACE)</code>), which immediately reduce the number of fragments in half.</p>

<p>To make things even faster, we can skip the surfaces that are right against a solid block. Only those that are behind air, transparent texture (e.g. water, leaves) or irregular shaped blocks (e.g. stairs) need to be rendered.</p>

<p>When parsing the region file, a hashmap is built to track whether each block is opaque or not. An accessor <code class="highlighter-rouge">getIsBlockOpaque</code> is introduced to the Minecraft Layer to look up the transparency flag for any block coordinates. The layer then creates an attribute <code class="highlighter-rouge">instanceVisibilities</code> which tells the vertex shader what’s next to each face of the cube. Here’s a comparison between rendering without and with this optimization:</p>

<p><img src="../img/minecraft4.jpg" alt="Face Visibility" /></p>

<h2 id="cool-whats-next">Cool, What’s Next?</h2>

<p>This all started as a weekend project. deck.gl was great as a foundation for this kind of experiment – it took care of most of the chores such as attribute mangement, update cycles, projection and picking. I was able to spend most of my time focusing on Minecraft-specific code.</p>

<p>Right now the chunk viewer only supports limited Minecraft block types, because I got lazy halfway into scraping the Wiki. My hacky tricks with cubes obviously will not work with every entity out there (no mobs, for example). But surely there are a lot more improvements I can make. Checkout the <a href="https://github.com/Pessimistress/minecraft-chunk-viewer/issues">issues list</a> and make a suggestion!</p>

<p>Now pardon me as I go dig up that diamond ore.</p>

	</div>

  <div class="tag-cloud">
    
      <a href="../tag/case-study">Case Study</a>
    
      <a href="../tag/custom-layer">Custom Layer</a>
    
      <a href="../tag/non-geospatial">Non-Geospatial</a>
    
  </div>

  <div class="navigation clearfix">
    
      <a class="float--left" href="../2017/introducing-deckgl-v4">&lt; Previous post: Introducing deck.gl v4.0</a>
    
    
  </div>

</article>



        </main>
      	
      	  <!-- Pagination links -->
          

        </div>
      </div>

      <div class="flexbox__item--collapsed">
        <!-- Footer -->
        


<footer>
  <div class="container">
    <img src="../img/logo.gif" />
  </div>
</footer>

      </div>

    </div>
  </div>
</body>
</html>
